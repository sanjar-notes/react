# 3. Working with multiple states
Created Saturday 24 January 2022

#### Why
A component may have more than one state. There are two ways to handle automatic re-rendering. Either use multiple `useState` or create a single object of all state variables (so just one `useState` is needed).

#### How
If multiple states are handled individually, then it's simple. But if all state variables are packed into a single state, then care must be taken to also keep the un-updated variable in each `setStateMethod` (of `useState`) call.

This must be done because just setting one attribute will **replace** other attributes. A shorthand is to use the **spread operator**, which results in cleaner code. 

Note: Spread operator actually merges the attribute, just remember keep the spread operator as the first attribute.

Here's a code example for multiple state:
1. Individual states
```jsx
import React, { useState } from 'React';

function MyComponent () {
	const [count, setCount] = useState(0);
	const [reverseCount, setReverseCount] = useState(999);

	const countClick = () => { setCount(count + 1); };
	const reverseCountClick = () => { setReverseCount(reverseCount - 1); };

	return (
		<div>
			<button onClick={countClick}>+: {count}</button> &nbsp;
			<button onClick={reverseCountClick}>-: {reverseCount} </button>
		</div>
	);
}

export default MultiStateMulti;
```

2. Single state object - all attributes have to be specified during update, otherwise they'll be lost. So we use the spread operator (`...state`) which merges the previous state with tne attribute we're updating.
```jsx
import React, { useState } from "react";

function MultiStateSingle() {
	const [state, setState] = useState({ count: 0, reverseCount: 999 });

	const countClick = () => {
		setState({
			...state,
		    count: state.count + 1, // will update/merge existing
		});
	};
	const reverseCountClick = () => {
		setState({
		    ...state,
			reverseCount: state.reverseCount - 1,
		});
	};

	return (
		<div>
			<button onClick={countClick}>+: {state.count}</button> 
			&nbsp;
			<button onClick={reverseCountClick}>-: {state.reverseCount}</button>
		</div>
	);
}

export default MultiStateSingle;
```

#### What
Here's the syntax:
1. Import `useState` from `react`.
2. Capture a variable using `useState`, and also get back an updater function. Add this code in the component.
3. Update the state using the updater method.
Example
```JSX
import React, { useState } from 'react';

function MyComponent (props) {
	const [title, setTitle] = useState(props.title);

	// some code/event that fires setTitle
	const clickHandler = () => {
		setTitle("Updated!"); // this sets the states and fires a re-render
	}

	return (<div>
			...
			<button onClick = {clickHandler}> Click me </button>
			...
			</div>);
}
```
Also see [project commit](https://github.com/exemplar-codes/expense-tracker-react/commit/45d42efca9e80754120da43d5989c05519a2965f).

###### General algorithm for `useState`
For the skeleton:
```JSX
function MyComponent {
	const [readVar, setVariable] = useState(capture_variable);
	// some code that calls setVariable
	// component code (JSX) returned.
}
```
is:
1. In the first pass:
	1. useState is initialized, state is set internally.
	2. Read variable set to state.
	3. Component is drawn.
2. In the second pass:
	1. useState argument (initialization) is ignored.
	2. State set to setState argument - setState is called from event/timer etc.
	3. Read variable set to state.
	4. Component is drawn.
3.  Step 2 repeats.
Note: `const` is OK for the read variable, because we never assign (`=`) anything to it. It's changed internally.