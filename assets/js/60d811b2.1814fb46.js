"use strict";(self.webpackChunkreactjs_notes_docu=self.webpackChunkreactjs_notes_docu||[]).push([[7645],{9613:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>_});var a=n(9496);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),h=l(n),d=i,_=h["".concat(c,".").concat(d)]||h[d]||p[d]||r;return n?a.createElement(_,s(s({ref:t},u),{},{components:n})):a.createElement(_,s({ref:t},u))}));function _(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=d;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o[h]="string"==typeof e?e:i,s[1]=o;for(var l=2;l<r;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7105:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var a=n(1163),i=(n(9496),n(9613));const r={},s="160. State scheduling and batching",o={unversionedId:"home/resource_itineraries/React_the_complete_guide/Behind_the_scenes_of_React_and_optimization_techniques/State_scheduling_and_batching",id:"home/resource_itineraries/React_the_complete_guide/Behind_the_scenes_of_React_and_optimization_techniques/State_scheduling_and_batching",title:"160. State scheduling and batching",description:"Created Monday 11 July 2022",source:"@site/docs/home/4_resource_itineraries/2_React_the_complete_guide/12_Behind_the_scenes_of_React_and_optimization_techniques/160_State_scheduling_and_batching.md",sourceDirName:"home/4_resource_itineraries/2_React_the_complete_guide/12_Behind_the_scenes_of_React_and_optimization_techniques",slug:"/home/resource_itineraries/React_the_complete_guide/Behind_the_scenes_of_React_and_optimization_techniques/State_scheduling_and_batching",permalink:"/reactjs-notes/docs/home/resource_itineraries/React_the_complete_guide/Behind_the_scenes_of_React_and_optimization_techniques/State_scheduling_and_batching",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/home/4_resource_itineraries/2_React_the_complete_guide/12_Behind_the_scenes_of_React_and_optimization_techniques/160_State_scheduling_and_batching.md",tags:[],version:"current",sidebarPosition:160,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"158. Component instance and state",permalink:"/reactjs-notes/docs/home/resource_itineraries/React_the_complete_guide/Behind_the_scenes_of_React_and_optimization_techniques/Component_instance_and_state"},next:{title:"161. Optimizing with useMemo",permalink:"/reactjs-notes/docs/home/resource_itineraries/React_the_complete_guide/Behind_the_scenes_of_React_and_optimization_techniques/Optimizing_with_useMemo"}},c={},l=[{value:"Why",id:"why",level:3},{value:"How",id:"how",level:3},{value:"What",id:"what",level:3}],u={toc:l},h="wrapper";function p(e){let{components:t,...r}=e;return(0,i.kt)(h,(0,a.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"160-state-scheduling-and-batching"},"160. State scheduling and batching"),(0,i.kt)("p",null,"Created Monday 11 July 2022"),(0,i.kt)("h3",{id:"why"},"Why"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"React batches state changes."),(0,i.kt)("li",{parentName:"ul"},"React can postpone state changes, in theory. This is done if there's some pending computation of higher priority.")),(0,i.kt)("h3",{id:"how"},"How"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"State changes are batched in order, for a given state. And yes, multiple state changes can be batched for the same state.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If there are multiple state updates, but for different states, i.e. if state change calls are close together (i.e. in a synchronous chain), then they are batched, and only ",(0,i.kt)("em",{parentName:"p"},"one")," re-evaluation takes place."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"const handler = () => {\n        setText('Hello');\n        // state is not updated here\n        setAge(24);\n    };\n")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"// even this, somewhat convulted example, works, React is smart in batching state changes\nconst handler = () => {\n    (() => setText('Hello'))();\n        // state is not updated here\n    (() => setAge(24))();\n}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The component is re-evaluated (and re-rendered) only after the all state changes have been processed.\n",(0,i.kt)("img",{src:n(8380).Z,width:"1769",height:"992"}))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Use a callback in the state mutation function, if the state to be set depends on the previous state. Do this because the latest state from the batch is available as the param. Example:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"const [count, setCount] = useState(0);\n\nsetCount(count + 1); // unsafe, not good\nsetCount(prevCount => prevCount + 1); // safe and better\n")),(0,i.kt)("p",{parentName:"li"},"Why do this? Because it could be the case that multiple state changes were batched and not all processed (i.e. re-evaluation has not taken place), so the state accessed is actually the one of the last component evaluation."))),(0,i.kt)("h3",{id:"what"},"What"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"State change batching is practically unobservable (because React is fast)."),(0,i.kt)("li",{parentName:"ul"},"The only issue can be the dependence of new state on the last change, which can be taken care of by using the callback version of the state mutation function (provided by ",(0,i.kt)("inlineCode",{parentName:"li"},"useState"),")."),(0,i.kt)("li",{parentName:"ul"},"Inside ",(0,i.kt)("inlineCode",{parentName:"li"},"useEffect"),", it is safe to use normal state update, even if depends on the previous state because ",(0,i.kt)("inlineCode",{parentName:"li"},"useEffect"),"'s code runs after the re-render, ensuring that all batched changes have finished processing."),(0,i.kt)("li",{parentName:"ul"},"State batching/processing is not something to worry about, generally.")))}p.isMDXComponent=!0},8380:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/160_State_scheduling_and_batching-image-1-2456f377bac5f0b3c6ee9a39382a916c.png"}}]);