"use strict";(self.webpackChunkreactjs_notes_docu=self.webpackChunkreactjs_notes_docu||[]).push([[7684],{9613:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var o=n(9496);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=o.createContext({}),l=function(e){var t=o.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=l(e.components);return o.createElement(p.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=l(n),d=i,h=m["".concat(p,".").concat(d)]||m[d]||u[d]||a;return n?o.createElement(h,r(r({ref:t},c),{},{components:n})):o.createElement(h,r({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,r=new Array(a);r[0]=d;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[m]="string"==typeof e?e:i,r[1]=s;for(var l=2;l<a;l++)r[l]=n[l];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2106:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var o=n(1163),i=(n(9496),n(9613));const a={},r="161. Optimizing with useMemo",s={unversionedId:"home/resource_itineraries/React_the_complete_guide/Behind_the_scenes_of_React_and_optimization_techniques/Optimizing_with_useMemo",id:"home/resource_itineraries/React_the_complete_guide/Behind_the_scenes_of_React_and_optimization_techniques/Optimizing_with_useMemo",title:"161. Optimizing with useMemo",description:"Created Thursday 14 July 2022",source:"@site/docs/home/4_resource_itineraries/2_React_the_complete_guide/12_Behind_the_scenes_of_React_and_optimization_techniques/161_Optimizing_with_useMemo.md",sourceDirName:"home/4_resource_itineraries/2_React_the_complete_guide/12_Behind_the_scenes_of_React_and_optimization_techniques",slug:"/home/resource_itineraries/React_the_complete_guide/Behind_the_scenes_of_React_and_optimization_techniques/Optimizing_with_useMemo",permalink:"/docs/home/resource_itineraries/React_the_complete_guide/Behind_the_scenes_of_React_and_optimization_techniques/Optimizing_with_useMemo",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/home/4_resource_itineraries/2_React_the_complete_guide/12_Behind_the_scenes_of_React_and_optimization_techniques/161_Optimizing_with_useMemo.md",tags:[],version:"current",sidebarPosition:161,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"160. State scheduling and batching",permalink:"/docs/home/resource_itineraries/React_the_complete_guide/Behind_the_scenes_of_React_and_optimization_techniques/State_scheduling_and_batching"},next:{title:"163. Module introduction",permalink:"/docs/home/resource_itineraries/React_the_complete_guide/Class_based_components/Module_introduction"}},p={},l=[{value:"Why",id:"why",level:3},{value:"How",id:"how",level:3},{value:"What",id:"what",level:3},{value:"Observations",id:"observations",level:3}],c={toc:l},m="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"161-optimizing-with-usememo"},"161. Optimizing with useMemo"),(0,i.kt)("p",null,"Created Thursday 14 July 2022"),(0,i.kt)("p",null,"All optimizations we have spoken about till now (i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"React.memo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"useCallback")," hook) are about preventing unnecessary re-evaluations of ",(0,i.kt)("em",{parentName:"p"},"child components"),". Now, we'll optimize computations inside a given component itself."),(0,i.kt)("h3",{id:"why"},"Why"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Components will do computations on data, from parts of the props/context. "),(0,i.kt)("li",{parentName:"ul"},"These computations can sometimes be expensive (time, space wise), and we would like to memoize them. Consider a general component:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"function MyComponent(props) {\n\n    const ec1 = expensiveComp1(props.data1); // stores computation\n    expensiveComp2(props.data2, props.data3); // returns void\n    \n    return <>...</>; // ignore, this, as we're focusing on component's own computations\n}\n")),(0,i.kt)("p",null,"Now, there's no need of optimizing component's self computations if :"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"It's the first evaluation."),(0,i.kt)("li",{parentName:"ol"},"If props have changed.")),(0,i.kt)("p",null,"So there's scope for optimization only if some parts of the props (relevant to expensive computations) have not changed. In other words, we need to do something like ",(0,i.kt)("inlineCode",{parentName:"p"},"React.memo")," (which works based prop diffing), but only check differences of certain props, and not all of them (",(0,i.kt)("inlineCode",{parentName:"p"},"React.memo")," does diffing of all)."),(0,i.kt)("h3",{id:"how"},"How"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"React provides a way to selectively do prop diffing in order to avoid expensive computations - the ",(0,i.kt)("inlineCode",{parentName:"li"},"useMemo")," hook."),(0,i.kt)("li",{parentName:"ul"},"Syntax - wrap the computation in the hook along with a dependency array of props involved:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"import {useMemo} from 'react';\n\nfunction MyComponent(props) {\n    const ec1 = useMemo(() => {\n        // ... computation involving\n        return expensiveComp1(props.data1)\n    }, [props.data1]);\n    \n    useMemo(() => { // void\n        // ... computation involving props.data2, props.data3\n        expensiveComp2(props.data2, props.data3)\n        // not returning is fine\n    }, [props.data2, props.data3]);\n    \n    return <>...</>;\n}```\nIn short:\n```jsx\nfunction App(props)\n{\n    const computedValue = useMemo(() => {return /* computations */}, [/*props involved in the computation*/]);\n\n    // OR, for void computations, don't assign, return anything\n    return <>...</>;\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"How does the hook work - just like ",(0,i.kt)("inlineCode",{parentName:"p"},"React.memo"),", i.e. React keeps a copy of:"),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"latest relevant props (as indicated in the dependency array(s)) of the component instance."),(0,i.kt)("li",{parentName:"ol"},"Latest evaluated value.\nUpon component re-evaluation, it executes the ",(0,i.kt)("inlineCode",{parentName:"li"},"useMemo")," callback only if the indicated props have changed and updates the computed value. Otherwise it returns the previously computed value."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Issues with reference values - consider the following code:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"import {useMemo} from 'react';\n\nfunction App() {\n    return <Child list={[10, -2, 34, 2]} />;\n}\n\nfunction Child(props) {\n    const sortedList = useMemo(() => props.list.sort(), [props.list]);\n    return <>...</>;\n}\n")),(0,i.kt)("p",{parentName:"li"},"Suppose the UI tree evaluates. When ",(0,i.kt)("inlineCode",{parentName:"p"},"App")," re-evaluates, it will cause re-evaluation of ",(0,i.kt)("inlineCode",{parentName:"p"},"Child"),", but will it recompute ",(0,i.kt)("inlineCode",{parentName:"p"},"sortedList"),"? Yes, it will. Reason: ",(0,i.kt)("inlineCode",{parentName:"p"},"props.list")," ",(0,i.kt)("em",{parentName:"p"},"has")," changed, because when ",(0,i.kt)("inlineCode",{parentName:"p"},"App")," was re-evaluated, it re-created the prop, and it won't be equal to stored prop (by the hook) because ",(0,i.kt)("inlineCode",{parentName:"p"},"Array")," is not a primitive data type."),(0,i.kt)("p",{parentName:"li"},"How to solve this? Use ",(0,i.kt)("inlineCode",{parentName:"p"},"useMemo")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"App")," (the parent) with an empty dependency array. This will ensure that the list is not re-created. The code will look like this"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"import {useMemo} from 'react';\n\nfunction App() {\n    return <Child list={useMemo(() => [10, -2, 34, 2], [])} />;\n\n    // or, alternatively\n    const list = useMemo(() => [10, -2, 34, 2], []);\n    return <Child list={list} />;\n}\n\nfunction Child(props) { // no change needed\n    const sortedList = useMemo(() => props.list.sort(), [props.list]);\n    return <>...</>;\n}\n")),(0,i.kt)("p",{parentName:"li"},'Note: This kind of "data memoization" does have certain overhead.'))),(0,i.kt)("h3",{id:"what"},"What"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Conditional execution with memoization of code based on selective prop diffing.")),(0,i.kt)("h3",{id:"observations"},"Observations"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"We can implement ",(0,i.kt)("inlineCode",{parentName:"li"},"React.memo")," using ",(0,i.kt)("inlineCode",{parentName:"li"},"useMemo"),", just pass the whole ",(0,i.kt)("inlineCode",{parentName:"li"},"props")," object as the dependency and move the return value inside the callback. Example:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"const {useMemo} from 'react';\nconst MyComponent(props) {\n    const retValue = useMemo(() => {\n        return <>...</>;\n    }, [props]);\n    \n    return retValue;\n}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"useCallback")," memoizes functions, but ",(0,i.kt)("inlineCode",{parentName:"li"},"useMemo")," memoizes all kinds of data.")),(0,i.kt)("p",null,"Assets"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/exemplar-codes/assorted-reactjs-apps/commit/194d02dadc8d2dfa773ecf5915c19c75df307315"},"Simple useMemo demo")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/exemplar-codes/assorted-reactjs-apps/commit/04dbea03bac4309c617322451e9f5f32785d6c43"},"Parent Child useMemo demo"))))}u.isMDXComponent=!0}}]);