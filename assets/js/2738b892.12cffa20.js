"use strict";(self.webpackChunkreactjs_notes_docu=self.webpackChunkreactjs_notes_docu||[]).push([[8437],{9613:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var i=n(9496);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=i.createContext({}),p=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(n),h=r,m=d["".concat(l,".").concat(h)]||d[h]||c[h]||a;return n?i.createElement(m,o(o({ref:t},u),{},{components:n})):i.createElement(m,o({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,o[1]=s;for(var p=2;p<a;p++)o[p]=n[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2933:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var i=n(1163),r=(n(9496),n(9613));const a={},o="298. Exploring routing issues and finishing deployment",s={unversionedId:"home/resource_itineraries/React_the_complete_guide/Deploying_React_apps/Exploring_routing_issues_and_finishing_deployment",id:"home/resource_itineraries/React_the_complete_guide/Deploying_React_apps/Exploring_routing_issues_and_finishing_deployment",title:"298. Exploring routing issues and finishing deployment",description:"Created Sunday 30 October 2022",source:"@site/docs/home/4_resource_itineraries/2_React_the_complete_guide/21_Deploying_React_apps/299_Exploring_routing_issues_and_finishing_deployment.md",sourceDirName:"home/4_resource_itineraries/2_React_the_complete_guide/21_Deploying_React_apps",slug:"/home/resource_itineraries/React_the_complete_guide/Deploying_React_apps/Exploring_routing_issues_and_finishing_deployment",permalink:"/docs/home/resource_itineraries/React_the_complete_guide/Deploying_React_apps/Exploring_routing_issues_and_finishing_deployment",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/home/4_resource_itineraries/2_React_the_complete_guide/21_Deploying_React_apps/299_Exploring_routing_issues_and_finishing_deployment.md",tags:[],version:"current",sidebarPosition:299,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"298. Getting started with deployment",permalink:"/docs/home/resource_itineraries/React_the_complete_guide/Deploying_React_apps/Getting_started_with_deployment"},next:{title:"301. Module introduction",permalink:"/docs/home/resource_itineraries/React_the_complete_guide/Adding_authentication_to_React_apps/Module_introduction"}},l={},p=[{value:"Situation",id:"situation",level:2},{value:"Why",id:"why",level:2},{value:"How",id:"how",level:2},{value:"What",id:"what",level:2},{value:"Question - lazy loading",id:"question---lazy-loading",level:2}],u={toc:p},d="wrapper";function c(e){let{components:t,...a}=e;return(0,r.kt)(d,(0,i.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"298-exploring-routing-issues-and-finishing-deployment"},"298. Exploring routing issues and finishing deployment"),(0,r.kt)("p",null,"Created Sunday 30 October 2022"),(0,r.kt)("h2",{id:"situation"},"Situation"),(0,r.kt)("p",null,"Let's consider a typical visit to our website (that uses client side routing) by a user:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Assume the first request URL is ",(0,r.kt)("inlineCode",{parentName:"li"},"/")," (i.e. your domain, without any path specified). Our static hosting server will provide the bundle files - HTML, CSS, JS and assets. If we are using lazy loading, the server provides the home page bundle."),(0,r.kt)("li",{parentName:"ul"},"The website loads successfully."),(0,r.kt)("li",{parentName:"ul"},"The user clicks on a button that routes them to, say ",(0,r.kt)("inlineCode",{parentName:"li"},"/path1"),". Because we are using ",(0,r.kt)("inlineCode",{parentName:"li"},"React Router"),", it detects the URL change, and renders (directly or by downloading lazy entities) the corresponding view."),(0,r.kt)("li",{parentName:"ul"},"OK, works fine.")),(0,r.kt)("p",null,"But what if the user directly enters a path in the URL bar? The server will receive a request for ",(0,r.kt)("inlineCode",{parentName:"p"},"/path1"),", consequently, it will try to find a file named ",(0,r.kt)("inlineCode",{parentName:"p"},"path1.html"),", which is actually absent since our website is a single page app, and we only have one shell (i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},"/")," - ",(0,r.kt)("inlineCode",{parentName:"p"},"index.html"),")."),(0,r.kt)("p",null,"The server will respond with a 404 error."),(0,r.kt)("p",null,"This is not good."),(0,r.kt)("p",null,"We should be able to load pages directly by path entered by the user as well."),(0,r.kt)("p",null,"The problem isn't with ",(0,r.kt)("inlineCode",{parentName:"p"},"react-router")," or any app code, it's with the server code. "),(0,r.kt)("p",null,"Solution - configure the server to ignore all request URL paths and treat them as ",(0,r.kt)("inlineCode",{parentName:"p"},"/"),"."),(0,r.kt)("p",null,"This time, when the user runs requests ",(0,r.kt)("inlineCode",{parentName:"p"},"/path1"),", the server receives a request with URL ",(0,r.kt)("inlineCode",{parentName:"p"},"/path1"),", but it ignores it and sends back website code for ",(0,r.kt)("inlineCode",{parentName:"p"},"/"),", which it successfully can. The browser receives the code, but ",(0,r.kt)("inlineCode",{parentName:"p"},"/path1")," URL is persisted in the browser. When the JavaScript code runs, ",(0,r.kt)("inlineCode",{parentName:"p"},"react-router")," notices ",(0,r.kt)("inlineCode",{parentName:"p"},"/path1")," and renders the corresponding view. Success."),(0,r.kt)("h2",{id:"why"},"Why"),(0,r.kt)("p",null,"Servers, by default, treat URL paths as location for files. This can be an issue for an SPA using client side routing. Because SPAs don't actually have files for different pages."),(0,r.kt)("p",null,"This can result in 404 errors. Thus, one needs to configure hosting servers for SPA to ignore paths."),(0,r.kt)("h2",{id:"how"},"How"),(0,r.kt)("p",null,"The simplest way, is to have server side code with a single route defined - ",(0,r.kt)("inlineCode",{parentName:"p"},"/*")," for the bundle code."),(0,r.kt)("h2",{id:"what"},"What"),(0,r.kt)("p",null,"Most static site ask or have an option to specify if the app is an SPA."),(0,r.kt)("h2",{id:"question---lazy-loading"},"Question - lazy loading"),(0,r.kt)("p",null,"Q: If the server responds to only one end point, how does one request for component that needs to be lazy loaded?\nA: Firebase seems to work apps that use lazy loading, after hosting as SPA code. And most other services do too. "),(0,r.kt)("p",null,"My guess, it's something like this. The server side code actually has 2 ",(0,r.kt)("em",{parentName:"p"},"types")," of routes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'"page" routes - there\'s only 1 for SPAs - (',(0,r.kt)("inlineCode",{parentName:"li"},"/(?!assets).*"),' - returns the app bundle files, or the "main" bundle files if app uses lazy loading)'),(0,r.kt)("li",{parentName:"ul"},'"asset" routes - can be multiple for SPA or MPA - ',(0,r.kt)("inlineCode",{parentName:"li"},"/assets/:asset_name")," - returns requested assets like CSS, JS, images, audio, text.")),(0,r.kt)("p",null,'When a user makes a path request, it\'s mostly of the "page" type, so they get the main bundle, ',(0,r.kt)("inlineCode",{parentName:"p"},"react-router"),' kicks in and makes "asset" requests for the lazy entities, and they are fetched.'),(0,r.kt)("p",null,"See (Browser DevTool > Network tab screenshot):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Initial load ",(0,r.kt)("img",{alt:"Initial load",src:n(863).Z,width:"1079",height:"247"})),(0,r.kt)("li",{parentName:"ul"},"Lazy loaded page ",(0,r.kt)("img",{alt:"Lazy loaded page",src:n(3864).Z,width:"1084",height:"117"}))))}c.isMDXComponent=!0},863:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/299_Exploring_routing_issues_and_finishing_deployment-image-1-61845ea486b6b2313273750fb25c696a.png"},3864:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/299_Exploring_routing_issues_and_finishing_deployment-image-2-2e82f109d810d16f1c128cd5e35f68bf.png"}}]);