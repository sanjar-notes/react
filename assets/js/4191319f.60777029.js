"use strict";(self.webpackChunkreactjs_notes_docu=self.webpackChunkreactjs_notes_docu||[]).push([[4755],{9613:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(9496);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),u=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(i.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(n),m=r,h=p["".concat(i,".").concat(m)]||p[m]||d[m]||o;return n?a.createElement(h,s(s({ref:t},c),{},{components:n})):a.createElement(h,s({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=m;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l[p]="string"==typeof e?e:r,s[1]=l;for(var u=2;u<o;u++)s[u]=n[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6034:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var a=n(1163),r=(n(9496),n(9613));const o={},s="3. Working with multiple states",l={unversionedId:"vault/State/Working_with_multiple_states",id:"vault/State/Working_with_multiple_states",title:"3. Working with multiple states",description:"Created Saturday 24 January 2022",source:"@site/docs/vault/4_State/3_Working_with_multiple_states.md",sourceDirName:"vault/4_State",slug:"/vault/State/Working_with_multiple_states",permalink:"/reactjs-notes/docs/vault/State/Working_with_multiple_states",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/vault/4_State/3_Working_with_multiple_states.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"1. Events and handlers in React",permalink:"/reactjs-notes/docs/vault/State/Events_and_handlers_in_React"},next:{title:"4. Two way Binding",permalink:"/reactjs-notes/docs/vault/State/Two_way_binding"}},i={},u=[{value:"Why",id:"why",level:4},{value:"How",id:"how",level:4}],c={toc:u},p="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"3-working-with-multiple-states"},"3. Working with multiple states"),(0,r.kt)("p",null,"Created Saturday 24 January 2022"),(0,r.kt)("h4",{id:"why"},"Why"),(0,r.kt)("p",null,"A component may have more than one state. There are two ways to handle automatic re-rendering. Either use multiple ",(0,r.kt)("inlineCode",{parentName:"p"},"useState")," or create a single object of all state variables (so just one ",(0,r.kt)("inlineCode",{parentName:"p"},"useState")," is needed)."),(0,r.kt)("h4",{id:"how"},"How"),(0,r.kt)("p",null,"If multiple states are handled individually, then it's simple. But if all state variables are packed into a single state, then care must be taken to also keep the un-updated variable in each ",(0,r.kt)("inlineCode",{parentName:"p"},"setStateMethod")," (of ",(0,r.kt)("inlineCode",{parentName:"p"},"useState"),") call."),(0,r.kt)("p",null,"This must be done because just setting one attribute will ",(0,r.kt)("strong",{parentName:"p"},"replace")," other attributes. A shorthand is to use the ",(0,r.kt)("strong",{parentName:"p"},"spread operator"),", which results in cleaner code. "),(0,r.kt)("p",null,"Note: Spread operator actually merges the attribute, just remember keep the spread operator as the first attribute."),(0,r.kt)("p",null,"Here's a code example for multiple state:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Individual states")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import React, { useState } from 'React';\n\nfunction MyComponent () {\n    const [count, setCount] = useState(0);\n    const [reverseCount, setReverseCount] = useState(999);\n\n    const countClick = () => { setCount(count + 1); };\n    const reverseCountClick = () => { setReverseCount(reverseCount - 1); };\n\n    return (\n        <div>\n            <button onClick={countClick}>+: {count}</button> &nbsp;\n            <button onClick={reverseCountClick}>-: {reverseCount} </button>\n        </div>\n    );\n}\n\nexport default MultiStateMulti;\n")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Single state object - all attributes have to be specified during update, otherwise they'll be lost. So we use the spread operator (",(0,r.kt)("inlineCode",{parentName:"li"},"...state"),") which merges the previous state with the attribute we are updating.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'import React, { useState } from "react";\n\nfunction MultiStateSingle() {\n    const [state, setState] = useState({ count: 0, reverseCount: 999 });\n\n    const countClick = () => {\n        setState({\n            ...state,\n            count: state.count + 1, // will update/merge existing\n        });\n    };\n    const reverseCountClick = () => {\n        setState({\n            ...state,\n            reverseCount: state.reverseCount - 1,\n        });\n    };\n\n    return (\n        <div>\n            <button onClick={countClick}>+: {state.count}</button> \n            &nbsp;\n            <button onClick={reverseCountClick}>-: {state.reverseCount}</button>\n        </div>\n    );\n}\n\nexport default MultiStateSingle;\n')),(0,r.kt)("p",null,"There's a BIG catch here. Most of the time, we are updating state based on its current value. This becomes a problem if we are using the spread operator. It is a problem because React actually schedules changes, instead of carrying them out immediately."),(0,r.kt)("p",null,"To avoid this, pass a function to the updater function instead of a value. This function must have one parameter (which will be the latest state) and return the updated state. The method gets called by the updater, automatically."),(0,r.kt)("p",null,"The updater code would look like this, ensuring that the latest state is update every-time."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"    const countClick = () => {\n        setState( (latestState) => {\n            return {\n                ...latestState,\n                count: latestState.count + 1,\n            };\n        });\n    };\n    const reverseCountClick = () => {\n        setState( (latestState) => {\n            return {\n                ...latestState,\n                reverseCount: latestState.reverseCount - 1,\n            };\n        });\n    };\n")),(0,r.kt)("p",null,"Note: FIXME, I've not completely understood why this function instead of direct update is needed, because even if changes are scheduled and not done immediately, the schedule can save a reference to the object, which will ensure latest state at all times."))}d.isMDXComponent=!0}}]);