"use strict";(self.webpackChunkreactjs_notes_docu=self.webpackChunkreactjs_notes_docu||[]).push([[8147],{9613:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(9496);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(n),h=o,d=c["".concat(s,".").concat(h)]||c[h]||m[h]||r;return n?a.createElement(d,i(i({ref:t},u),{},{components:n})):a.createElement(d,i({ref:t},u))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:o,i[1]=l;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8028:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(1163),o=(n(9496),n(9613));const r={},i="155. Preventing Unnecessary Re-Evaluations with React.memo()",l={unversionedId:"home/resource_itineraries/React_the_complete_guide/Behind_the_scenes_of_React_and_optimization_techniques/Preventing_Unnecessary_ReEvaluations_with_React_memo",id:"home/resource_itineraries/React_the_complete_guide/Behind_the_scenes_of_React_and_optimization_techniques/Preventing_Unnecessary_ReEvaluations_with_React_memo",title:"155. Preventing Unnecessary Re-Evaluations with React.memo()",description:"Created Sunday 10 July 2022",source:"@site/docs/home/4_resource_itineraries/2_React_the_complete_guide/12_Behind_the_scenes_of_React_and_optimization_techniques/155_Preventing_Unnecessary_ReEvaluations_with_React_memo.md",sourceDirName:"home/4_resource_itineraries/2_React_the_complete_guide/12_Behind_the_scenes_of_React_and_optimization_techniques",slug:"/home/resource_itineraries/React_the_complete_guide/Behind_the_scenes_of_React_and_optimization_techniques/Preventing_Unnecessary_ReEvaluations_with_React_memo",permalink:"/docs/home/resource_itineraries/React_the_complete_guide/Behind_the_scenes_of_React_and_optimization_techniques/Preventing_Unnecessary_ReEvaluations_with_React_memo",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/home/4_resource_itineraries/2_React_the_complete_guide/12_Behind_the_scenes_of_React_and_optimization_techniques/155_Preventing_Unnecessary_ReEvaluations_with_React_memo.md",tags:[],version:"current",sidebarPosition:155,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"154. A closer look at child component re evaluation",permalink:"/docs/home/resource_itineraries/React_the_complete_guide/Behind_the_scenes_of_React_and_optimization_techniques/A_closer_look_at_child_component_re_evaluation"},next:{title:"156. Prevent function re-evaluation with useCallback",permalink:"/docs/home/resource_itineraries/React_the_complete_guide/Behind_the_scenes_of_React_and_optimization_techniques/Prevent_function_re_creation_with_useCallback"}},s={},p=[{value:"Why",id:"why",level:3},{value:"How",id:"how",level:3},{value:"What (syntax and details)",id:"what-syntax-and-details",level:2},{value:"Basic usage",id:"basic-usage",level:3},{value:"Custom diff usage",id:"custom-diff-usage",level:3},{value:"MAid",id:"maid",level:2},{value:"Thoughts",id:"thoughts",level:2}],u={toc:p},c="wrapper";function m(e){let{components:t,...n}=e;return(0,o.kt)(c,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"155-preventing-unnecessary-re-evaluations-with-reactmemo"},"155. Preventing Unnecessary Re-Evaluations with React.memo()"),(0,o.kt)("p",null,"Created Sunday 10 July 2022"),(0,o.kt)("h3",{id:"why"},"Why"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"In the last page, we acknowledged that in React, when a component re-evaluates, so do all of it's constituents, even if their props haven't change (which includes not having any). This ",(0,o.kt)("em",{parentName:"li"},"is")," inefficient.")),(0,o.kt)("h3",{id:"how"},"How"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Solving the problem",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"The solution is simple, just compare the old and new props and run the component function only if there's a change. If there's no change, return the stored copy of the render output, i.e. don't compute it again. React provides this functionality out of the box."),(0,o.kt)("li",{parentName:"ul"},"This optimization is a trade-off though - prop diffing vs function re-evaluation. ",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"And it depends (on number/complexity of props, number of child components) which is costly, so use ",(0,o.kt)("inlineCode",{parentName:"li"},"React.memo")," with care."),(0,o.kt)("li",{parentName:"ul"},"If it's known that props will change frequently, it's better to avoid using ",(0,o.kt)("inlineCode",{parentName:"li"},"React.memo"),"."),(0,o.kt)("li",{parentName:"ul"},"It's better to use ",(0,o.kt)("inlineCode",{parentName:"li"},"React.memo")," to avoid re-evaluations of whole UI tree sections, of course knowing that props don't change very frequently."))),(0,o.kt)("li",{parentName:"ul"},"Why isn't this 'prop-diffing' the default - because of the overhead of prop-diffing."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Important note")," - ",(0,o.kt)("inlineCode",{parentName:"li"},"React.memo")," is only concerned with props. State changes will always cause a re-evaluation, ",(0,o.kt)("inlineCode",{parentName:"li"},"React.memo")," has no control over that.")),(0,o.kt)("h2",{id:"what-syntax-and-details"},"What (syntax and details)"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Skeleton - ",(0,o.kt)("inlineCode",{parentName:"li"},"export default React.memo(Component, [areEqualCallback])"))),(0,o.kt)("h3",{id:"basic-usage"},"Basic usage"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Just wrap the component function, for which you want to do prop diffing of ",(0,o.kt)("em",{parentName:"p"},"received props"),", with ",(0,o.kt)("inlineCode",{parentName:"p"},"React.memo()"),". So, a normal component like this:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"const MyComponent = (props) => { return <> ...</>; };\n\nexport default MyComponent;\n")),(0,o.kt)("p",{parentName:"li"},"becomes"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"import React from 'react'; // cannot be skipped if using memo\nconst MyComponent = (props) => { return <> ...</>; };\n\nexport default React.memo(MyComponent);\n\n\n// OR equivalently\nconst MyComponent = React.memo((props) => { return <> ...</>; });\n\nexport default MyComponent;\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"React.memo")," can also be used on components that don't receive props."))),(0,o.kt)("h3",{id:"custom-diff-usage"},"Custom diff usage"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},'Intent - the following construct is provided by React because it only does "shallow" comparison of props, i.e. only checks if the reference has changed or not. This is not sufficient at all, since props are objects. Even if there are no props, the props value if ',(0,o.kt)("inlineCode",{parentName:"li"},"{}"),", and ",(0,o.kt)("inlineCode",{parentName:"li"},"{} === {}")," is false in JavaScript."),(0,o.kt)("li",{parentName:"ul"},"The second argument of ",(0,o.kt)("inlineCode",{parentName:"li"},"React.memo")," is optional. It's a function."),(0,o.kt)("li",{parentName:"ul"},"Parameters: previous and current (new) props, in this order."),(0,o.kt)("li",{parentName:"ul"},"Return value specifies if function should re-run (and potentially re-render) or not. So:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"true")," - don't run"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"false")," - do run"))),(0,o.kt)("li",{parentName:"ul"},"By default it returns false.")),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'const MyButton = React.memo(\n  ({ title }) => {\n    const clickHandler = () => window.alert("Hello");\n    \n    return <button onClick={clickHandler}> {title} </button>;\n  },\n  (prevProps, curProps) => prevProps.title === curProps.title\n);\n')),(0,o.kt)("h2",{id:"maid"},"MAid"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"useMemo")," helps us prevent re-evaluations of components when the app tree re-renders. Additionally, it can do this w.r.t props."),(0,o.kt)("h2",{id:"thoughts"},"Thoughts"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The prevent re-run with component without props case should be default behavior. "),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://stackoverflow.com/questions/53074551/when-should-you-not-use-react-memo"},"More info"),"."),(0,o.kt)("li",{parentName:"ul"},"Maybe not - what if the propless component uses ",(0,o.kt)("inlineCode",{parentName:"li"},"Math.random")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"new Date()"),". Ignoring the opinions of React.Strict, how to do this - because re-evaluation does lead to change in UI even though props have not changed. ",(0,o.kt)("em",{parentName:"li"},'It\'s kind of like the external API are a "prop" that have changed')," - this seems to be a good excuse to have the current behavior (i.e. re-rerun no matter what)."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"How does the hook work? My guess:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"React keeps a copy of two things internally:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Props received in the latest evaluation."),(0,o.kt)("li",{parentName:"ul"},"Return value of the latest evaluation."))),(0,o.kt)("li",{parentName:"ul"},"If props have changed, it re-evaluates the function and stores both props and return value. And returns the return value to the parent."),(0,o.kt)("li",{parentName:"ul"},"If props haven't changed, it just returns the stored return value of the latest evaluation to the parent."),(0,o.kt)("li",{parentName:"ul"},'Note: the return value is stored "kind of" in the component itself (which was wrapped in ',(0,o.kt)("inlineCode",{parentName:"li"},"React.memo"),"), and not it's parent. This means that the parent is oblivious to the fact that it received a stored value instead of a newly computed one. FIXME(I'm not sure if the both props and return value are stored in the parent or not. Also need to find out if the parent knows if one of it's children value was a stored value, not a computed one, maybe the parent is aware, idk)"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"How to control re-evaluation w.r.t both state + props? FIXME (this was popular in class components). BTW: I never had to do this, during experiments or work, atleast knowingly. How would I do it without a new hook, approaches:"),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"State changed, there are no props. FIXME: continue later: ",(0,o.kt)("a",{parentName:"li",href:"https://codesandbox.io/s/angry-agnesi-4e4be2?file=/src/App.js"},"https://codesandbox.io/s/angry-agnesi-4e4be2?file=/src/App.js"),". Also see ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/facebook/react/issues/14110"},"discussion on bailing out of state upates")," - I actually encountered this somewhere in the Redux section, oh, ",(0,o.kt)("a",{parentName:"li",href:"obsidian://open?vault=reactjs-notes&file=home%2F4_resource_itineraries%2F2_React_the_complete_guide%2F25_Replacing_Redux_with_React_hooks%2F372_Alternative__using_the_Context_API"},"here"),". ")),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'function stateComparator(prevState, currentState) { // true means don\'t re-evaluate\n    return ...; // some diffing logic\n}\n\nfunction MyShell() {\n    const [command, setCommand] = useState("App initialized");\n    \n    return <div>\n        <input onChange={(e) => setState(e.target.value} value={command} />\n        <br /> <span>{command}</span></div>;\n}\n')))))}m.isMDXComponent=!0}}]);