"use strict";(self.webpackChunkreactjs_notes_docu=self.webpackChunkreactjs_notes_docu||[]).push([[4126],{9613:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var o=n(9496);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,s=function(e,t){if(null==e)return{};var n,o,s={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,s=e.mdxType,r=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=l(n),u=s,h=m["".concat(c,".").concat(u)]||m[u]||d[u]||r;return n?o.createElement(h,a(a({ref:t},p),{},{components:n})):o.createElement(h,a({ref:t},p))}));function h(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=n.length,a=new Array(r);a[0]=u;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[m]="string"==typeof e?e:s,a[1]=i;for(var l=2;l<r;l++)a[l]=n[l];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9314:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var o=n(1163),s=(n(9496),n(9613));const r={},a="167. Component life-cycles in class components",i={unversionedId:"home/resource_itineraries/React_the_complete_guide/Class_based_components/Component_lifecycles_in_class_components",id:"home/resource_itineraries/React_the_complete_guide/Class_based_components/Component_lifecycles_in_class_components",title:"167. Component life-cycles in class components",description:"Created Monday 15 July 2022",source:"@site/docs/home/4_resource_itineraries/2_React_the_complete_guide/13_Class_based_components/167_Component_lifecycles_in_class_components.md",sourceDirName:"home/4_resource_itineraries/2_React_the_complete_guide/13_Class_based_components",slug:"/home/resource_itineraries/React_the_complete_guide/Class_based_components/Component_lifecycles_in_class_components",permalink:"/reactjs-notes/docs/home/resource_itineraries/React_the_complete_guide/Class_based_components/Component_lifecycles_in_class_components",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/home/4_resource_itineraries/2_React_the_complete_guide/13_Class_based_components/167_Component_lifecycles_in_class_components.md",tags:[],version:"current",sidebarPosition:167,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"166. Working with state and events",permalink:"/reactjs-notes/docs/home/resource_itineraries/React_the_complete_guide/Class_based_components/Working_with_state_and_events"},next:{title:"169. Context API with class components",permalink:"/reactjs-notes/docs/home/resource_itineraries/React_the_complete_guide/Class_based_components/Context_API_with_class_components"}},c={},l=[{value:"Learnings",id:"learnings",level:3},{value:"An important observation - re-instantiation of components is avoided, unless absolutely needed",id:"an-important-observation---re-instantiation-of-components-is-avoided-unless-absolutely-needed",level:3}],p={toc:l},m="wrapper";function d(e){let{components:t,...n}=e;return(0,s.kt)(m,(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"167-component-life-cycles-in-class-components"},"167. Component life-cycles in class components"),(0,s.kt)("p",null,"Created Monday 15 July 2022"),(0,s.kt)("p",null,"Class based components can't use React hooks. So how do we run side-effects?"),(0,s.kt)("p",null,"Class based components have a somewhat imperative API for running side-effects, which exposes the life-cycle methods directly."),(0,s.kt)("p",null,"The most common life-cycle methods are:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("inlineCode",{parentName:"li"},"componentDidMount")," - called after the component first mount (i.e. evaluation and render are complete) to the DOM. Equivalent to ",(0,s.kt)("inlineCode",{parentName:"li"},"useEffect(..., [])"),"."),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("inlineCode",{parentName:"li"},"componentDidUpdate")," - called after the component has updated (i.e. evaluation and ",(0,s.kt)("em",{parentName:"li"},"potential")," render are complete) to the DOM. Equivalent to ",(0,s.kt)("inlineCode",{parentName:"li"},"useEffect(...)"),". If one uses ",(0,s.kt)("inlineCode",{parentName:"li"},"if")," conditions inside this function, it'll become equivalent to ",(0,s.kt)("inlineCode",{parentName:"li"},"useEffect(..., [someValue])"),"."),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("inlineCode",{parentName:"li"},"componentWillUnmount")," - called just before the component is unmounted from the DOM. Equivalent to the cleanup function of ",(0,s.kt)("inlineCode",{parentName:"li"},"useEffect"),".")),(0,s.kt)("p",null,"Transform functional component that uses ",(0,s.kt)("inlineCode",{parentName:"p"},"useEffect"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'import { useState, useEffect } from "react";\nimport classes from "./UserFinder.module.css";\nimport Users from "./Users";\n\nconst DUMMY_USERS = [\n  { id: "u1", name: "Max" },\n  { id: "u2", name: "Manuel" },\n  { id: "u3", name: "Julie" },\n];\n\nconst UserFinder = () => {\n  const [filteredUsers, setFilteredUsers] = useState(DUMMY_USERS);\n  const [searchTerm, setSearchTerm] = useState("");\n\n  useEffect(() => {\n    setFilteredUsers(\n      DUMMY_USERS.filter((user) =>\n        user.name.toLowerCase().includes(searchTerm.trim().toLowerCase())\n      )\n    );\n  }, [searchTerm]);\n\n  const searchChangeHandler = (event) => {\n    setSearchTerm(event.target.value);\n  };\n\n  return (\n    <div className={classes["finder"]}>\n      <input type="search" onChange={searchChangeHandler} />\n      <Users users={filteredUsers} />\n    </div>\n  );\n};\n\nexport default UserFinder;\n')),(0,s.kt)("p",null,"to class based component:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'import { Component } from \'react\';\n\nclass UserFinder extends Component {\n  constructor() {\n    super();\n    this.state = { filteredUsers: DUMMY_USERS, searchTerm: "" };\n  }\n\n  searchChangeHandler(event) {\n    this.setState({ searchTerm: event.target.value });\n  }\n\n  /*\n  useEffect(() => {\n    setFilteredUsers(\n      DUMMY_USERS.filter((user) =>\n        user.name.toLowerCase().includes(searchTerm.trim().toLowerCase())\n      )\n    );\n  }, [searchTerm]);\n  */\n  \n  componentDidUpdate(prevProps, prevState) {\n    if (prevState.searchTerm !== this.state.searchTerm) {\n      // update list\n      this.setState({\n        filteredUsers: DUMMY_USERS.filter((user) =>\n          user.name\n            .toLowerCase()\n            .includes(this.state.searchTerm.trim().toLowerCase())\n        ),\n      });\n    }\n  }\n\n  render() {\n    return (\n      <div className={classes["finder"]}>\n        <input type="search" onChange={this.searchChangeHandler.bind(this)} />\n        <p>{this.state.searchTerm}</p>\n        <Users users={this.state.filteredUsers} />\n      </div>\n    );\n  }\n}\n\nexport default UserFinder;\n')),(0,s.kt)("h3",{id:"learnings"},"Learnings"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("inlineCode",{parentName:"li"},"componentDidUpdate")," receives two parameters - previous props and previous state. These may be compared with the new props or state, in order to avoid infinite loops.",(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"componentDidUpdate(prevProps, prevState) {\n   if(prevState.x != this.state.x) {\n       // do something\n   }\n}\n"))),(0,s.kt)("li",{parentName:"ol"},"Using life-cycle methods in classes is a different mental model. It is more imperative, and less concise than ",(0,s.kt)("inlineCode",{parentName:"li"},"useEffect")," in functional components.")),(0,s.kt)("h3",{id:"an-important-observation---re-instantiation-of-components-is-avoided-unless-absolutely-needed"},"An important observation - re-instantiation of components is avoided, unless absolutely needed"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"componentDidUpdate")," function receives previous props, in addition to previous state.\nHaving previous state was fine, but why does it receive previous props? Well the answer to this question is that when comparing (during tree diffing) two ",(0,s.kt)("em",{parentName:"p"},"custom")," components of the same type, even if there are changes in props, the instance of the component remains the same (this is actually the reason state is preserved between renders), irrespective of prop changes. Of course React runs the ",(0,s.kt)("inlineCode",{parentName:"p"},"render")," method and then diffs it with the existing tree."),(0,s.kt)("p",null,"In short, the important thing to note here is that components are instantiated only once, even between multiple renders, including if the re-render call came from the ancestor i.e. re-evaluation is related to ",(0,s.kt)("inlineCode",{parentName:"p"},"render")," output instead of ",(0,s.kt)("inlineCode",{parentName:"p"},"constructor"),"."),(0,s.kt)("p",null,"Source: ",(0,s.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/reconciliation.html#component-elements-of-the-same-type"},"https://reactjs.org/docs/reconciliation.html#component-elements-of-the-same-type")),(0,s.kt)("p",null,"It could be argued that this an arbitrary decision by the React team, one could have re-instantiated custom components on each render and only saved previous state (which is obvious - it should be saved), and not previous props. It does, however, make a change to React, in that we have retained some extra information, i.e. previous props, which may be used if needed. If previous props are not saved, it does not matter if you re-instantiate or not, at-least from an API point of view (ignoring performance), because the amount of information, and hence the set of possible actions would remain unchanged."),(0,s.kt)("p",null,"FIXME: get a little more comfortable with how this works. I'm a little foggy with this, but it doesn't matter, this is a nuanced implementation detail."))}d.isMDXComponent=!0}}]);