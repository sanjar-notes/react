"use strict";(self.webpackChunkreactjs_notes_docu=self.webpackChunkreactjs_notes_docu||[]).push([[3157],{9613:(e,r,t)=>{t.d(r,{Zo:()=>u,kt:()=>h});var n=t(9496);function o(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function a(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?a(Object(t),!0).forEach((function(r){o(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function s(e,r){if(null==e)return{};var t,n,o=function(e,r){if(null==e)return{};var t,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)t=a[n],r.indexOf(t)>=0||(o[t]=e[t]);return o}(e,r);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)t=a[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=n.createContext({}),c=function(e){var r=n.useContext(l),t=r;return e&&(t="function"==typeof e?e(r):i(i({},r),e)),t},u=function(e){var r=c(e.components);return n.createElement(l.Provider,{value:r},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},m=n.forwardRef((function(e,r){var t=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(t),m=o,h=d["".concat(l,".").concat(m)]||d[m]||p[m]||a;return t?n.createElement(h,i(i({ref:r},u),{},{components:t})):n.createElement(h,i({ref:r},u))}));function h(e,r){var t=arguments,o=r&&r.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=m;var s={};for(var l in r)hasOwnProperty.call(r,l)&&(s[l]=r[l]);s.originalType=e,s[d]="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=t[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}m.displayName="MDXCreateElement"},5862:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var n=t(1163),o=(t(9496),t(9613));const a={},i="171. Introducing Error Boundaries",s={unversionedId:"home/resource_itineraries/React_the_complete_guide/Class_based_components/Introducing_Error_Boundaries",id:"home/resource_itineraries/React_the_complete_guide/Class_based_components/Introducing_Error_Boundaries",title:"171. Introducing Error Boundaries",description:"Created Monday 18 July 2022",source:"@site/docs/home/4_resource_itineraries/2_React_the_complete_guide/13_Class_based_components/171_Introducing_Error_Boundaries.md",sourceDirName:"home/4_resource_itineraries/2_React_the_complete_guide/13_Class_based_components",slug:"/home/resource_itineraries/React_the_complete_guide/Class_based_components/Introducing_Error_Boundaries",permalink:"/docs/home/resource_itineraries/React_the_complete_guide/Class_based_components/Introducing_Error_Boundaries",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/home/4_resource_itineraries/2_React_the_complete_guide/13_Class_based_components/171_Introducing_Error_Boundaries.md",tags:[],version:"current",sidebarPosition:171,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"170. Class vs function components: A summary",permalink:"/docs/home/resource_itineraries/React_the_complete_guide/Class_based_components/Class_vs_function_components_a_summary"},next:{title:"173. Module Introduction",permalink:"/docs/home/resource_itineraries/React_the_complete_guide/Sending_HTTP_requests/Module_Introduction"}},l={},c=[{value:"Why",id:"why",level:3},{value:"How",id:"how",level:3},{value:"Error handling solutions",id:"error-handling-solutions",level:5},{value:"Error boundaries",id:"error-boundaries",level:5},{value:"A note about error boundary(s)",id:"a-note-about-error-boundarys",level:5}],u={toc:c},d="wrapper";function p(e){let{components:r,...t}=e;return(0,o.kt)(d,(0,n.Z)({},u,t,{components:r,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"171-introducing-error-boundaries"},"171. Introducing Error Boundaries"),(0,o.kt)("p",null,"Created Monday 18 July 2022"),(0,o.kt)("h3",{id:"why"},"Why"),(0,o.kt)("p",null,"There are sometimes errors which are:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Used for informational purposes, i.e. error handling between different parts of an application."),(0,o.kt)("li",{parentName:"ol"},"Cannot generally be fixed. For example - if the server is temporarily not responding.")),(0,o.kt)("p",null,"So why not use error handling normally? Well, if a child component throws an error, the ",(0,o.kt)("inlineCode",{parentName:"p"},"catch")," should be inside the same component (and function). In short, it cannot be handled in a parent component."),(0,o.kt)("h3",{id:"how"},"How"),(0,o.kt)("h5",{id:"error-handling-solutions"},"Error handling solutions"),(0,o.kt)("p",null,"One way to do error handling is to create a context with error initialized to ",(0,o.kt)("inlineCode",{parentName:"p"},"null"),". Then, instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"throw"),'ing an error, we\'ll simply call a function (defined in this "error" context). The context provider will conditionally handle the error and show a message etc. See this ',(0,o.kt)("a",{parentName:"p",href:"https://github.com/exemplar-codes/react-with-classes/commit/625ea216b0f7356c7039a03a7bfe13436407c04d"},"code"),"."),(0,o.kt)("p",null,"This is, of course, not so elegant - we are having to import context, then call a function defined in it. A better way would be to just catch ",(0,o.kt)("inlineCode",{parentName:"p"},"throw"),'n errors directly by the kind of "error" context provider. This is possible if make changes to the React core library to catch error bubbling up from the source of ',(0,o.kt)("inlineCode",{parentName:"p"},"throw"),"."),(0,o.kt)("p",null,'React implements a functionally similar feature, called "Error boundary".'),(0,o.kt)("h5",{id:"error-boundaries"},"Error boundaries"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"An error boundary is simply a ",(0,o.kt)("em",{parentName:"li"},"class")," based React component that implements the ",(0,o.kt)("inlineCode",{parentName:"li"},"componentDidCatch")," method. That's all. The error boundary also implements the usual ",(0,o.kt)("inlineCode",{parentName:"li"},"render")," function."),(0,o.kt)("li",{parentName:"ul"},"This error boundary wraps the app, or parts of it. When any of it's ancestor throws an error, the ",(0,o.kt)("inlineCode",{parentName:"li"},"componentDidCatch")," method is called."),(0,o.kt)("li",{parentName:"ul"},"When the error occurs, we should show some error UI. But we will first need to cause a re-render. To do that, we use state in the error boundary component. To cause the re-render, we mutate the state inside ",(0,o.kt)("inlineCode",{parentName:"li"},"componentDidCatch"),". "),(0,o.kt)("li",{parentName:"ul"},"When the error occurs, ",(0,o.kt)("inlineCode",{parentName:"li"},"componentDidCatch")," gets called, where, as said, we mutate state to indicate that an error has occurred. In the next re-render the ",(0,o.kt)("inlineCode",{parentName:"li"},"render")," method of the error boundary gets called, and we conditionally avoid the usual flow of the app, rendering a message component instead. By default the error boundary just render s",(0,o.kt)("inlineCode",{parentName:"li"},"props.children"),"."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"componentDidCatch")," has a parameter with the error that occurred available.")),(0,o.kt)("p",null,"So, to add an error boundary to an app:\nA. Create the class boundary"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"1. Create a class based component with state indicating if an error has occured, and set it to `false`.\n2. Implement the `componentDidCatch` method so that it sets the state to specify that an error has occurred.\n3. Implement the `render` method to return `props.children` by default, and conditionally return an error component (or message).\n")),(0,o.kt)("p",null,"B. Using the error boundary - wrap the potentially error causing part of the app by the error boundary (component).\nC. You can now throw error by using ",(0,o.kt)("inlineCode",{parentName:"p"},"throw"),".\nThat's all"),(0,o.kt)("p",null,"Example - Consider the following app."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"import {Component} from 'react';\nimport MyUser from '.../path';\n\nfunction App() {\n    return <MyUser />;\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"function MyUser() {\n    return <button onClick={() => {throw new Error('Error occured');}}>Trigger Error</button>;\n}\n\nexport default MyUser;\n")),(0,o.kt)("p",null,"Let's define an error boundary to handle the error. Note, it must be a class based component:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"import {Component} from 'react';\n\nclass MyErrorBoundary extends Component {\n    constructor() { // need state to cause a re-render when error occurs\n        super();\n        this.state = {hasError: false, error: null};\n    }\n\n    componentDidCatch(error) {\n        this.setState({hasError:true, error: error});\n    }\n\n    render() {\n        return this.state.hasError ? <p>Error Occured</p> : this.props.children;\n    }\n}\n\nexport default MyErrorBoundary;\n")),(0,o.kt)("p",null,"To use the error boundary, wrap the potentially error causing component inside it. For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"\nfunction App() {\n    return <MyErrorBoundary><MyUsers /></MyErrorBoundary>;\n}\n")),(0,o.kt)("p",null,"The error will now be caught."),(0,o.kt)("h5",{id:"a-note-about-error-boundarys"},"A note about error boundary(s)"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"One may use multiple error boundaries and conditionally handle different types of errors, i.e. by using implementing ",(0,o.kt)("inlineCode",{parentName:"li"},"componentDidCatch")," conditionally based on ",(0,o.kt)("inlineCode",{parentName:"li"},"error")," parameter it provides."),(0,o.kt)("li",{parentName:"ul"},'Or use a single error boundary and use switch cases, with the state containing many types of "error has occurred".')))}p.isMDXComponent=!0}}]);