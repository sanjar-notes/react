"use strict";(self.webpackChunkreactjs_notes_docu=self.webpackChunkreactjs_notes_docu||[]).push([[5495],{9613:(e,t,r)=>{r.d(t,{Zo:()=>d,kt:()=>h});var n=r(9496);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},d=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(r),m=i,h=c["".concat(l,".").concat(m)]||c[m]||u[m]||a;return r?n.createElement(h,o(o({ref:t},d),{},{components:r})):n.createElement(h,o({ref:t},d))}));function h(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<a;p++)o[p]=r[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},8683:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var n=r(1163),i=(r(9496),r(9613));const a={},o="335. How pre-rendering works and problems we face",s={unversionedId:"home/resource_itineraries/React_the_complete_guide/Intro_to_Next_js/Prerendering_and_related_constructs/How_pre-rendering_works_and_problems_we_face",id:"home/resource_itineraries/React_the_complete_guide/Intro_to_Next_js/Prerendering_and_related_constructs/How_pre-rendering_works_and_problems_we_face",title:"335. How pre-rendering works and problems we face",description:"Created Saturday 17 December 2022",source:"@site/docs/home/4_resource_itineraries/2_React_the_complete_guide/23_Intro_to_Next_js/6_Prerendering_and_related_constructs/335_How_pre-rendering_works_and_problems_we_face.md",sourceDirName:"home/4_resource_itineraries/2_React_the_complete_guide/23_Intro_to_Next_js/6_Prerendering_and_related_constructs",slug:"/home/resource_itineraries/React_the_complete_guide/Intro_to_Next_js/Prerendering_and_related_constructs/How_pre-rendering_works_and_problems_we_face",permalink:"/reactjs-notes/docs/home/resource_itineraries/React_the_complete_guide/Intro_to_Next_js/Prerendering_and_related_constructs/How_pre-rendering_works_and_problems_we_face",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/home/4_resource_itineraries/2_React_the_complete_guide/23_Intro_to_Next_js/6_Prerendering_and_related_constructs/335_How_pre-rendering_works_and_problems_we_face.md",tags:[],version:"current",sidebarPosition:335,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"333. Programmatic navigation",permalink:"/reactjs-notes/docs/home/resource_itineraries/React_the_complete_guide/Intro_to_Next_js/Onwards_to_a_bigger_project/Programmatic_navigation"},next:{title:"338. More about SSR with getServerSideProps",permalink:"/reactjs-notes/docs/home/resource_itineraries/React_the_complete_guide/Intro_to_Next_js/Prerendering_and_related_constructs/More_about_SSR_with_getServerSideProps"}},l={},p=[{value:"SSG (Static Site Generation)",id:"ssg-static-site-generation",level:2},{value:"SSR (Server Side Rendering)",id:"ssr-server-side-rendering",level:2},{value:"ISR",id:"isr",level:2},{value:"Important thing about pre-rendering in Next.js",id:"important-thing-about-pre-rendering-in-nextjs",level:2},{value:"Pre-rendering in Next.js, in a nutshell",id:"pre-rendering-in-nextjs-in-a-nutshell",level:2}],d={toc:p},c="wrapper";function u(e){let{components:t,...r}=e;return(0,i.kt)(c,(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"335-how-pre-rendering-works-and-problems-we-face"},"335. How pre-rendering works and problems we face"),(0,i.kt)("p",null,"Created Saturday 17 December 2022"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Pre-rendering in the context of SPAs means that we ship atleast some markup in our UI response."),(0,i.kt)("li",{parentName:"ul"},"This is the most popular reason for using Next.js")),(0,i.kt)("p",null,"Pre-rendering is not an absolute term, and lies on a spectrum. 3 levels of it are:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"No pre-rendering - empty SPA shell, completely hyrdated on the client side. Example - plain React app."),(0,i.kt)("li",{parentName:"ol"},"Some pre-rendering - some parts are present in the UI, others are hydrated on the client side. Next.js apps"),(0,i.kt)("li",{parentName:"ol"},"Full pre-rendering - all (as much as possible) parts of the requested page are already there in markup.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Next.js allows us to do all 3, but the default behavior is ","#","3 (full pre-rendering)."))),(0,i.kt)("p",null,"It is important to note that choosing a pre-rendering level depends on the web page, audience, data velocity etc."),(0,i.kt)("p",null,"Next.js provides us with 3 constructs, which may be used to change the level of pre-rendering and the time (build time or request time) it is carried out, for a ",(0,i.kt)("em",{parentName:"p"},"given page"),"."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},'SSG - Static Site Generation - build page at "build time".'),(0,i.kt)("li",{parentName:"ol"},"SSR - Server Side Rendering - build page at every request."),(0,i.kt)("li",{parentName:"ol"},"ISR - Incremental Server Rendering - build the page every 't' seconds, or some other criteria.")),(0,i.kt)("h2",{id:"ssg-static-site-generation"},"SSG (Static Site Generation)"),(0,i.kt)("p",null,'This is a pre-rendering mechanism, where the server builds the page at "build time".'),(0,i.kt)("p",null,"In Next.js, the ",(0,i.kt)("inlineCode",{parentName:"p"},"getStaticProps")," function is used for SSG. "),(0,i.kt)("p",null,'It is a function that runs at build time (so, on the server - things like filesystem, databases are all available) and returns some "props" that become available to the page component. Thus, files are generated and can be used as server responses.'),(0,i.kt)("p",null,"It is only available for pages. To use it export (normal not ",(0,i.kt)("inlineCode",{parentName:"p"},"default"),") a function named ",(0,i.kt)("inlineCode",{parentName:"p"},"getStaticProps")," in the page file."),(0,i.kt)("p",null,"Note that using SSG (or ",(0,i.kt)("inlineCode",{parentName:"p"},"getStaticProps"),") doesn't mean one ",(0,i.kt)("em",{parentName:"p"},"has to")," hydrate the whole page on build time. For example, if you have a fetch (or ",(0,i.kt)("inlineCode",{parentName:"p"},"useEffect"),") request inside the component, it will be ignored by Next.js (since it pre-renders the first snapshot returned by the page component), but will still run on the client. Of course, this also means that the resulting changes won't be there in the pre-rendered UI, which is may or may not be OK."),(0,i.kt)("h2",{id:"ssr-server-side-rendering"},"SSR (Server Side Rendering)"),(0,i.kt)("p",null,"This is a pre-rendering mechanism, where the server builds the page on each request."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'This is the "default" in Next.js'),". One doesn't need to actually specify/code anything to enable this, the page component is enough. However, if one needs to run some server side code (for authentication, DB lookup etc), there is a way to do it - the ",(0,i.kt)("inlineCode",{parentName:"p"},"getServerSideProps")," function."),(0,i.kt)("p",null,"It behaves similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"getStaticProps"),", but runs for every request. Additionally, it also receives the request and response objects as its parameters, and so can be used for authentication, responding with a status code etc."),(0,i.kt)("p",null,"It is only available for pages. To use it export a function named ",(0,i.kt)("inlineCode",{parentName:"p"},"getServerSideProps")," in the page file."),(0,i.kt)("p",null,"SSR, like SSG, also doesn't mean all data has to there that the page uses, i.e. the page could hydrate parts of it on the client."),(0,i.kt)("h2",{id:"isr"},"ISR"),(0,i.kt)("p",null,"For medium-low velocity data, we may wish to rebuild our site in, say, 10 seconds. This pre-rendering technique is called Increment Static Regeneration (ISR)."),(0,i.kt)("p",null,"This can be achieved using the ",(0,i.kt)("inlineCode",{parentName:"p"},"getStaticProps")," function. "),(0,i.kt)("p",null,"Of course, we'd need a running server for this to happen."),(0,i.kt)("p",null,"To do this, add a ",(0,i.kt)("inlineCode",{parentName:"p"},"revalidate")," attribute in the object returned by ",(0,i.kt)("inlineCode",{parentName:"p"},"getStaticProps"),", value being the time to re-build, in seconds."),(0,i.kt)("p",null,"In simple words, the data is not older than ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," seconds."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"export const MyPage = ({someProp}) => { ... };\n\nexport async function getStaticProps() {\n  return {\n    props: {...},\n    revalidate: 10\n  }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/exemplar-codes/nextjs-first-realistic-tutorial/commit/93c7b7deb8b45b21172f46012eec56e7b250e9a1"},"Code example")),(0,i.kt)("h2",{id:"important-thing-about-pre-rendering-in-nextjs"},"Important thing about pre-rendering in Next.js"),(0,i.kt)("p",null,"Next.js pre-renders only the first snapshot of the page component. This means that ",(0,i.kt)("inlineCode",{parentName:"p"},"useEffect")," and other stuff will be completely ignored by Next.js. ",(0,i.kt)("inlineCode",{parentName:"p"},"getStaticProps")," or",(0,i.kt)("inlineCode",{parentName:"p"},"getServerSideProps")," will work as usual, since they are run before the component is executed for pre-rendering."),(0,i.kt)("p",null,"This is safe though, from a functionality point of view, since Next.js will still properly include and bundle ",(0,i.kt)("inlineCode",{parentName:"p"},"useEffect")," and other logic that it ignores in pre-rendering."),(0,i.kt)("h2",{id:"pre-rendering-in-nextjs-in-a-nutshell"},"Pre-rendering in Next.js, in a nutshell"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Page-wise mechanism")," - SSG/SSR/ISR is decided for each page (by marked by existence of ",(0,i.kt)("inlineCode",{parentName:"li"},"getStaticProps"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"getServerSideProp"),", and is therefore not a global setting (i.e. for all pages)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Default behavior")," - Again, re-emphasizing that Next.js's default behavior is pre-rendering on every request, even if there's no ",(0,i.kt)("inlineCode",{parentName:"li"},"getServerSideProps")," for the page."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"First snapshot only")," - Only the first snapshot of the page component is considered for pre-rendering. So things like ",(0,i.kt)("inlineCode",{parentName:"li"},"useEffect")," are ignored for pre-rendering. They are still included in the the bundle though. Because ",(0,i.kt)("inlineCode",{parentName:"li"},"get*Props")," functions run before pre-rendering, they are always included. Example - ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/exemplar-codes/nextjs-first-realistic-tutorial/commit/15abe08c666afbfb956ec906e244765a7fd0d1c9"},"useEffect ignored"),", ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/exemplar-codes/nextjs-first-realistic-tutorial/commit/54f9dce6154cb7abaf3de710a622f5a660e8647f"},"getStaticProps works fine")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Server side code remains hidden from client")," - Both ",(0,i.kt)("inlineCode",{parentName:"li"},"getStaticProps")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"getServerSideProps")," are a server-side construct. They are not shipped to the client, so it's safe to do sensitive computations here.")),(0,i.kt)("p",null,"Note: "),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Using client side code (for example - browser APIs or React UI constructs like hooks) inside ",(0,i.kt)("inlineCode",{parentName:"li"},"getStaticProps")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"getServerSideProps")," is an error, since they are purely server side constructs."),(0,i.kt)("li",{parentName:"ol"},"Both functions can be ",(0,i.kt)("inlineCode",{parentName:"li"},"async"),". There are no changes required in the page component, since the component is run only when the pre-rendering function completes/promise resolves.")))}u.isMDXComponent=!0}}]);